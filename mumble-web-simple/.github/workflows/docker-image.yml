name: Build and push to DockerHub

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  push:
    branches: ["lite"]
    tags: ["*"]
  pull_request:
    branches: ["lite"]

env:
  TEST_TAG: jafudi/mumbling-mole:test
  SMOKE_HTTP_PORT: "8081"
  E2E_WS_PORT: "8082"
  E2E_TCP_PORT: "5900"

jobs:
  docker:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Setup Node 22
        uses: actions/setup-node@v5
        with:
          node-version: '22.x'
          cache: 'npm'

      - name: Install dependencies for audit
        run: npm ci --omit=optional || npm i --omit=optional

      - name: Security audit gate
        run: npm run audit:ci

      - name: Dependency check gate
        run: npm run check:deps

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: jafudi/mumbling-mole
          tags: |
            type=ref,event=tag
            type=ref,event=branch
            type=sha

      - name: Login to DockerHub
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build image (prod stage, amd64 only)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          target: prod
          load: true
          tags: |
            ${{ env.TEST_TAG }}
            ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: HTML smoke test (:${{ env.SMOKE_HTTP_PORT }})
        env:
          SMOKE_HTTP_PORT: ${{ env.SMOKE_HTTP_PORT }}
        run: |
          set -euo pipefail
          cleanup() { docker rm -f mm-http >/dev/null 2>&1 || true; }
          trap cleanup EXIT

          echo "[smoke] Starting container for static HTML check on port ${SMOKE_HTTP_PORT}"
          docker run -d --rm \
            -p ${SMOKE_HTTP_PORT}:8081 \
            -e SKIP_TUNNEL=1 \
            --name mm-http \
            ${{ env.TEST_TAG }}

          # Wait (max ~30s) for HTTP 200 on root
          for i in {1..30}; do
            status=$(curl -sk -o /dev/null -w '%{http_code}' "http://127.0.0.1:${SMOKE_HTTP_PORT}" || true)
            if [ "$status" = "200" ]; then
              break
            fi
            sleep 1
          done

          if [ "${status:-}" != "200" ]; then
            echo "[smoke][fail] Did not receive HTTP 200 from :${SMOKE_HTTP_PORT} (last status='${status}')"
            echo "---- docker logs (mm-http) ----"; docker logs mm-http || true
            exit 1
          fi

          # Fetch raw headers and body separately (avoid verbose prefix noise)
          curl -sS -D /tmp/headers -o /tmp/body "http://127.0.0.1:${SMOKE_HTTP_PORT}" || {
            echo "[smoke][fail] curl fetch failed"; exit 1; }

          echo "[smoke] Response headers:"; sed 's/^/[H] /' /tmp/headers

          # Basic header assertions (allow charset parameter, case-insensitive)
          if ! grep -Ei '^Content-Type: *text/html(;|$)' /tmp/headers; then
            # Fallback: if body clearly contains HTML structure, warn instead of hard fail
            if grep -qi '<html' /tmp/body; then
              echo "[smoke][warn] Content-Type header missing or not text/html, but HTML tag found in body"
            else
              echo "[smoke][fail] Expected Content-Type: text/html (headers above)"; exit 1
            fi
          fi

          bytes=$(wc -c </tmp/body | awk '{print $1}')
          echo "[smoke] Body size: ${bytes} bytes"
          if [ "${bytes}" -lt 200 ]; then
            echo "[smoke][fail] HTML body unexpectedly small (<200 bytes)"; exit 1
          fi

          # Look for structural HTML marker in built index.html
          # Strategy:
          # 1. Ensure structural tag (<html or <!DOCTYPE html>) exists
          # 2. Body already asserted non-empty & minimum size above
          if grep -Fqi '<!DOCTYPE html>' /tmp/body || grep -Fqi '<html' /tmp/body; then
            echo "[smoke] HTML structure marker ok"
          else
            echo "[smoke][fail] No <html> or <!DOCTYPE html> tag found"; exit 1
          fi

          # If the served index.html is unexpectedly tiny (< 500 bytes) dump it for diagnostics
          if [ "$bytes" -lt 500 ]; then
            echo "[smoke][diag] index.html content (truncated to 400 bytes):"
            head -c 400 /tmp/body | sed 's/^/[body] /'
          fi

          # Direct asset fetch tests (avoid depending on inline <script> tags in minimized HTML)
          asset_checks=(config.js theme.js)
          for asset in "${asset_checks[@]}"; do
            echo "[smoke] Fetching asset: $asset"
            curl -sS -D "/tmp/hdr-$asset" -o "/tmp/$asset" "http://127.0.0.1:${SMOKE_HTTP_PORT}/$asset" || { echo "[smoke][fail] curl error for $asset"; exit 1; }
            astatus=$(awk 'NR==1{print $2}' "/tmp/hdr-$asset")
            if [ "${astatus}" != "200" ]; then
              echo "[smoke][fail] HTTP $astatus for $asset"; exit 1
            fi
            asize=$(wc -c </tmp/$asset | awk '{print $1}')
            echo "[smoke] $asset size: $asize bytes"
            if [ "$asize" -lt 50 ]; then
              echo "[smoke][fail] $asset unexpectedly small (<50 bytes)"; exit 1
            fi
          done

          echo "[smoke][ok] Static HTML served correctly with expected markers"


      - name: Run container for E2E
        env:
          E2E_WS_PORT: ${{ env.E2E_WS_PORT }}
          E2E_TCP_PORT: ${{ env.E2E_TCP_PORT }}
        run: |
          set -euo pipefail
          docker rm -f mm-e2e >/dev/null 2>&1 || true

          docker run -d --rm \
            --name mm-e2e \
            --add-host host.docker.internal:host-gateway \
            -p ${E2E_WS_PORT}:8081 \
            -e MUMBLE_SERVER=host.docker.internal:${E2E_TCP_PORT} \
            -e PLAIN_TARGET=1 \
            ${{ env.TEST_TAG }}

      - name: E2E websocket tunnel (echo roundtrip)
        env:
          E2E_WS_PORT: ${{ env.E2E_WS_PORT }}
          E2E_TCP_PORT: ${{ env.E2E_TCP_PORT }}
          E2E_TARGET_HOST: "127.0.0.1"
        run: node scripts/e2e-check.cjs --mode=container

      - name: Debug logs (mm-e2e)
        if: failure()
        run: |
          echo "----- docker logs mm-e2e -----"
          docker logs mm-e2e || true
          echo "----- netstat (ports) -----"
          ss -ltnp || true

      - name: Cleanup E2E container
        if: always()
        run: docker rm -f mm-e2e || true

      - name: Push image tags
        if: github.event_name != 'pull_request'
        run: |
          set -euo pipefail
          echo "${{ steps.meta.outputs.tags }}" | tr ' ' '\n' | while read -r tag; do
            if [ -n "$tag" ]; then
              echo "Pushing $tag"
              docker push "$tag"
            fi
          done
