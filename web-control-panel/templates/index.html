<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mumble AI Control Panel</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .stat-card h3 {
            color: #667eea;
            font-size: 0.9em;
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        .stat-card .value {
            font-size: 2.5em;
            font-weight: bold;
            color: #333;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: white;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .panel h2 {
            color: #667eea;
            margin-bottom: 20px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: 600;
        }

        input, select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 1em;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: background 0.3s;
        }

        button:hover {
            background: #5568d3;
        }

        button.danger {
            background: #e74c3c;
        }

        button.danger:hover {
            background: #c0392b;
        }

        .conversation-history {
            max-height: 500px;
            overflow-y: auto;
            background: #f8f9fa;
            border-radius: 5px;
            padding: 15px;
        }

        .message {
            margin-bottom: 15px;
            padding: 12px;
            border-radius: 8px;
            border-left: 4px solid;
        }

        .message.user {
            background: #e3f2fd;
            border-left-color: #2196f3;
        }

        .message.assistant {
            background: #f3e5f5;
            border-left-color: #9c27b0;
        }

        .message-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.85em;
            color: #666;
        }

        .message-content {
            color: #333;
        }

        textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: inherit;
            font-size: 1em;
            resize: vertical;
            min-height: 100px;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            display: none;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            display: none;
        }

        .full-width {
            grid-column: 1 / -1;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéôÔ∏è Mumble AI Control Panel</h1>

        <!-- Statistics -->
        <div class="stats-grid">
            <div class="stat-card">
                <h3>Total Messages</h3>
                <div class="value" id="stat-total">0</div>
            </div>
            <div class="stat-card">
                <h3>Unique Users</h3>
                <div class="value" id="stat-users">0</div>
            </div>
            <div class="stat-card">
                <h3>Voice Messages</h3>
                <div class="value" id="stat-voice">0</div>
            </div>
            <div class="stat-card">
                <h3>Text Messages</h3>
                <div class="value" id="stat-text">0</div>
            </div>
        </div>

        <!-- Main Panels -->
        <div class="grid">
            <!-- Ollama Configuration -->
            <div class="panel">
                <h2>ü§ñ Ollama Configuration</h2>
                <div class="success-message" id="ollama-success">Settings saved successfully!</div>
                <div class="error-message" id="ollama-error">Error saving settings</div>

                <div class="form-group">
                    <label for="ollama-url">Ollama Server URL</label>
                    <input type="text" id="ollama-url" placeholder="http://host.docker.internal:11434">
                </div>

                <div class="form-group">
                    <label for="ollama-model">Model</label>
                    <select id="ollama-model">
                        <option value="">Loading...</option>
                    </select>
                </div>

                <button onclick="saveOllamaConfig()">Save Configuration</button>
                <button onclick="refreshModels()" style="margin-left: 10px; background: #3498db;">Refresh Models</button>
            </div>

            <!-- TTS Engine Configuration -->
            <div class="panel">
                <h2>üîä Text-to-Speech Engine</h2>
                <div class="success-message" id="tts-success">Settings saved successfully!</div>

                <div class="form-group">
                    <label for="tts-engine">TTS Engine</label>
                    <select id="tts-engine" onchange="changeTTSEngine(this.value)">
                        <option value="piper">Piper TTS (CPU)</option>
                        <option value="silero">Silero TTS (GPU - Faster)</option>
                    </select>
                    <p style="font-size: 0.85em; color: #666; margin-top: 5px;">
                        üí° Silero uses your GPU for much faster speech generation
                    </p>
                </div>

                <!-- Piper Voice Selection (hidden when Silero is selected) -->
                <div id="piper-voice-selection">
                    <div class="form-group">
                        <label for="piper-voice-select">Piper Voice</label>
                        <select id="piper-voice-select" onchange="selectPiperVoice(this.value)">
                            <option value="">Loading...</option>
                        </select>
                    </div>
                    <button onclick="previewPiperVoice()" style="background: #3498db;">üîä Preview Piper Voice</button>
                </div>

                <!-- Silero Voice Selection (hidden when Piper is selected) -->
                <div id="silero-voice-selection" style="display: none;">
                    <div class="form-group">
                        <label for="silero-voice-select">Silero Voice</label>
                        <select id="silero-voice-select" onchange="selectSileroVoice(this.value)">
                            <option value="">Loading...</option>
                        </select>
                    </div>
                    <button onclick="previewSileroVoice()" style="background: #3498db;">üîä Preview Silero Voice</button>
                </div>
            </div>

            <!-- Whisper Language Configuration -->
            <div class="panel">
                <h2>üé§ Whisper Speech Recognition</h2>
                <div class="success-message" id="whisper-success">Language setting saved successfully!</div>

                <div class="form-group">
                    <label for="whisper-language">Language</label>
                    <select id="whisper-language" onchange="saveWhisperLanguage()">
                        <option value="auto">Auto-detect</option>
                        <option value="en">English</option>
                        <option value="es">Spanish</option>
                        <option value="fr">French</option>
                        <option value="de">German</option>
                        <option value="it">Italian</option>
                        <option value="pt">Portuguese</option>
                        <option value="nl">Dutch</option>
                        <option value="ru">Russian</option>
                        <option value="zh">Chinese</option>
                        <option value="ja">Japanese</option>
                        <option value="ko">Korean</option>
                        <option value="ar">Arabic</option>
                        <option value="hi">Hindi</option>
                        <option value="pl">Polish</option>
                        <option value="tr">Turkish</option>
                        <option value="vi">Vietnamese</option>
                    </select>
                    <p style="font-size: 0.85em; color: #666; margin-top: 5px;">
                        üí° Tip: Select a specific language if auto-detect is choosing the wrong language.
                    </p>
                </div>
            </div>

            <!-- Bot Persona Configuration -->
            <div class="panel">
                <h2>ü§ñ Bot Persona</h2>
                <div class="success-message" id="persona-success">Persona saved successfully!</div>

                <div class="form-group">
                    <label for="persona-text">Persona Description</label>
                    <textarea id="persona-text" rows="6" placeholder="Describe how the bot should behave and talk. For example: 'You are a friendly assistant who speaks casually with humor.' Leave empty for default behavior."></textarea>
                    <p style="font-size: 0.85em; color: #666; margin-top: 5px;">
                        üí° Tip: Use the AI Enhance button to let the AI expand and improve your persona description.
                    </p>
                </div>

                <button onclick="savePersona()">Save Persona</button>
                <button onclick="enhancePersona()" style="margin-left: 10px; background: #e74c3c;">‚ú® AI Enhance</button>
                <button onclick="clearPersona()" style="margin-left: 10px; background: #95a5a6;">Clear</button>
            </div>
        </div>

        <!-- Conversation History -->
        <div class="panel full-width">
            <h2>üí¨ Conversation History</h2>
            <div style="margin-bottom: 15px;">
                <button onclick="loadConversations()">Refresh</button>
                <button class="danger" onclick="resetConversations()" style="float: right;">Clear All History</button>
            </div>

            <div class="conversation-history" id="conversation-history">
                <p>Loading conversations...</p>
            </div>
        </div>
    </div>

    <script>
        // Load initial data
        document.addEventListener('DOMContentLoaded', function() {
            loadStats();
            loadOllamaConfig();
            loadTTSEngine();
            loadWhisperLanguage();
            loadPersona();
            loadConversations();

            // Refresh stats every 10 seconds
            setInterval(loadStats, 10000);
        });

        async function loadStats() {
            try {
                const response = await fetch('/api/stats');
                const data = await response.json();

                document.getElementById('stat-total').textContent = data.total_messages;
                document.getElementById('stat-users').textContent = data.unique_users;
                document.getElementById('stat-voice').textContent = data.voice_messages;
                document.getElementById('stat-text').textContent = data.text_messages;
            } catch (error) {
                console.error('Error loading stats:', error);
            }
        }

        async function loadOllamaConfig() {
            try {
                const response = await fetch('/api/ollama/config');
                const data = await response.json();

                document.getElementById('ollama-url').value = data.url;

                // Load available models
                await refreshModels();

                // Set current model
                document.getElementById('ollama-model').value = data.model;
            } catch (error) {
                console.error('Error loading Ollama config:', error);
            }
        }

        async function refreshModels() {
            try {
                const response = await fetch('/api/ollama/models');
                const data = await response.json();

                const select = document.getElementById('ollama-model');
                const currentValue = select.value;

                select.innerHTML = '';

                if (data.models && data.models.length > 0) {
                    data.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model;
                        option.textContent = model;
                        select.appendChild(option);
                    });

                    select.value = currentValue;
                } else {
                    select.innerHTML = '<option value="">No models found</option>';
                }
            } catch (error) {
                console.error('Error refreshing models:', error);
                document.getElementById('ollama-error').textContent = 'Error loading models';
                document.getElementById('ollama-error').style.display = 'block';
            }
        }

        async function saveOllamaConfig() {
            const url = document.getElementById('ollama-url').value;
            const model = document.getElementById('ollama-model').value;

            try {
                const response = await fetch('/api/ollama/config', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({url, model})
                });

                if (response.ok) {
                    const successMsg = document.getElementById('ollama-success');
                    successMsg.style.display = 'block';
                    setTimeout(() => successMsg.style.display = 'none', 3000);
                }
            } catch (error) {
                console.error('Error saving config:', error);
                const errorMsg = document.getElementById('ollama-error');
                errorMsg.style.display = 'block';
                setTimeout(() => errorMsg.style.display = 'none', 3000);
            }
        }

        async function loadTTSEngine() {
            try {
                const response = await fetch('/api/tts/engine');
                const data = await response.json();
                document.getElementById('tts-engine').value = data.engine || 'piper';

                // Load voices for the selected engine
                if (data.engine === 'silero') {
                    document.getElementById('piper-voice-selection').style.display = 'none';
                    document.getElementById('silero-voice-selection').style.display = 'block';
                    await loadSileroVoices();
                } else {
                    document.getElementById('piper-voice-selection').style.display = 'block';
                    document.getElementById('silero-voice-selection').style.display = 'none';
                    await loadPiperVoices();
                }
            } catch (error) {
                console.error('Error loading TTS engine:', error);
            }
        }

        async function changeTTSEngine(engine) {
            try {
                const response = await fetch('/api/tts/engine', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({engine})
                });

                if (response.ok) {
                    // Show/hide appropriate voice selection
                    if (engine === 'silero') {
                        document.getElementById('piper-voice-selection').style.display = 'none';
                        document.getElementById('silero-voice-selection').style.display = 'block';
                        await loadSileroVoices();
                    } else {
                        document.getElementById('piper-voice-selection').style.display = 'block';
                        document.getElementById('silero-voice-selection').style.display = 'none';
                        await loadPiperVoices();
                    }

                    const successMsg = document.getElementById('tts-success');
                    successMsg.style.display = 'block';
                    setTimeout(() => successMsg.style.display = 'none', 3000);
                }
            } catch (error) {
                console.error('Error changing TTS engine:', error);
            }
        }

        async function loadPiperVoices() {
            try {
                const [voicesResp, currentResp] = await Promise.all([
                    fetch('/api/piper/voices'),
                    fetch('/api/piper/current')
                ]);

                const voicesData = await voicesResp.json();
                const currentData = await currentResp.json();

                const select = document.getElementById('piper-voice-select');
                select.innerHTML = '';

                if (voicesData.voices.length === 0) {
                    select.innerHTML = '<option>No voices available</option>';
                    return;
                }

                // Group voices by region
                const voicesByRegion = {};
                voicesData.voices.forEach(voice => {
                    if (!voicesByRegion[voice.region]) {
                        voicesByRegion[voice.region] = [];
                    }
                    voicesByRegion[voice.region].push(voice);
                });

                // Create optgroups for each region
                Object.keys(voicesByRegion).sort().forEach(region => {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = region;

                    voicesByRegion[region].forEach(voice => {
                        const option = document.createElement('option');
                        option.value = voice.name;

                        // Format: speaker (Gender, quality)
                        const genderLabel = voice.gender !== 'Neutral' ? ` - ${voice.gender}` : '';
                        option.textContent = `${voice.speaker}${genderLabel} (${voice.quality})`;

                        if (voice.name === currentData.voice) {
                            option.selected = true;
                        }
                        optgroup.appendChild(option);
                    });

                    select.appendChild(optgroup);
                });
            } catch (error) {
                console.error('Error loading Piper voices:', error);
            }
        }

        async function loadSileroVoices() {
            try {
                const [voicesResp, currentResp] = await Promise.all([
                    fetch('/api/silero/voices'),
                    fetch('/api/silero/current')
                ]);

                const voicesData = await voicesResp.json();
                const currentData = await currentResp.json();

                const select = document.getElementById('silero-voice-select');
                select.innerHTML = '';

                if (!voicesData.voices || voicesData.voices.length === 0) {
                    select.innerHTML = '<option>No voices available</option>';
                    return;
                }

                // Group voices by gender
                const voicesByGender = {female: [], male: []};
                voicesData.voices.forEach(voice => {
                    if (voice.gender === 'female') {
                        voicesByGender.female.push(voice);
                    } else if (voice.gender === 'male') {
                        voicesByGender.male.push(voice);
                    }
                });

                // Create optgroups for each gender
                ['female', 'male'].forEach(gender => {
                    if (voicesByGender[gender].length > 0) {
                        const optgroup = document.createElement('optgroup');
                        optgroup.label = gender.charAt(0).toUpperCase() + gender.slice(1) + ' Voices';

                        voicesByGender[gender].forEach(voice => {
                            const option = document.createElement('option');
                            option.value = voice.id;
                            option.textContent = `${voice.id} - ${voice.description}`;

                            if (voice.id === currentData.voice) {
                                option.selected = true;
                            }
                            optgroup.appendChild(option);
                        });

                        select.appendChild(optgroup);
                    }
                });
            } catch (error) {
                console.error('Error loading Silero voices:', error);
            }
        }

        async function selectPiperVoice(voice) {
            if (!voice) return;

            try {
                const response = await fetch('/api/piper/current', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({voice})
                });

                if (response.ok) {
                    const successMsg = document.getElementById('tts-success');
                    successMsg.style.display = 'block';
                    setTimeout(() => successMsg.style.display = 'none', 3000);
                }
            } catch (error) {
                console.error('Error selecting Piper voice:', error);
            }
        }

        async function selectSileroVoice(voice) {
            if (!voice) return;

            try {
                const response = await fetch('/api/silero/current', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({voice})
                });

                if (response.ok) {
                    const successMsg = document.getElementById('tts-success');
                    successMsg.style.display = 'block';
                    setTimeout(() => successMsg.style.display = 'none', 3000);
                }
            } catch (error) {
                console.error('Error selecting Silero voice:', error);
            }
        }

        async function previewPiperVoice() {
            const voice = document.getElementById('piper-voice-select').value;
            if (!voice) {
                alert('Please select a voice first');
                return;
            }

            const btn = event.target;
            btn.disabled = true;
            btn.textContent = '‚è≥ Generating...';

            try {
                const response = await fetch('/api/piper/preview', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({voice})
                });

                if (response.ok) {
                    const audioBlob = await response.blob();
                    const audioUrl = URL.createObjectURL(audioBlob);
                    const audio = new Audio(audioUrl);
                    audio.play();
                } else {
                    alert('Error generating preview');
                }
            } catch (error) {
                console.error('Error previewing voice:', error);
                alert('Error previewing voice');
            } finally {
                btn.disabled = false;
                btn.textContent = 'üîä Preview Piper Voice';
            }
        }

        async function previewSileroVoice() {
            const voice = document.getElementById('silero-voice-select').value;
            if (!voice) {
                alert('Please select a voice first');
                return;
            }

            const btn = event.target;
            btn.disabled = true;
            btn.textContent = '‚è≥ Generating...';

            try {
                const response = await fetch('/api/silero/preview', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({voice})
                });

                if (response.ok) {
                    const audioBlob = await response.blob();
                    const audioUrl = URL.createObjectURL(audioBlob);
                    const audio = new Audio(audioUrl);
                    audio.play();
                } else {
                    alert('Error generating preview');
                }
            } catch (error) {
                console.error('Error previewing voice:', error);
                alert('Error previewing voice');
            } finally {
                btn.disabled = false;
                btn.textContent = 'üîä Preview Silero Voice';
            }
        }

        async function loadPersona() {
            try {
                const response = await fetch('/api/persona');
                const data = await response.json();
                document.getElementById('persona-text').value = data.persona || '';
            } catch (error) {
                console.error('Error loading persona:', error);
            }
        }

        async function savePersona() {
            const persona = document.getElementById('persona-text').value;

            try {
                const response = await fetch('/api/persona', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({persona})
                });

                if (response.ok) {
                    const successMsg = document.getElementById('persona-success');
                    successMsg.style.display = 'block';
                    setTimeout(() => successMsg.style.display = 'none', 3000);
                }
            } catch (error) {
                console.error('Error saving persona:', error);
            }
        }

        async function enhancePersona() {
            const currentPersona = document.getElementById('persona-text').value.trim();

            if (!currentPersona) {
                alert('Please enter a basic persona description first, then click AI Enhance to expand it.');
                return;
            }

            const enhanceBtn = event.target;
            enhanceBtn.disabled = true;
            enhanceBtn.textContent = '‚è≥ Enhancing...';

            try {
                const response = await fetch('/api/persona/enhance', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({persona: currentPersona})
                });

                if (response.ok) {
                    const data = await response.json();
                    document.getElementById('persona-text').value = data.enhanced_persona;

                    const successMsg = document.getElementById('persona-success');
                    successMsg.textContent = 'Persona enhanced successfully!';
                    successMsg.style.display = 'block';
                    setTimeout(() => {
                        successMsg.style.display = 'none';
                        successMsg.textContent = 'Persona saved successfully!';
                    }, 3000);
                } else {
                    alert('Error enhancing persona. Make sure Ollama is running.');
                }
            } catch (error) {
                console.error('Error enhancing persona:', error);
                alert('Error enhancing persona. Make sure Ollama is running.');
            } finally {
                enhanceBtn.disabled = false;
                enhanceBtn.textContent = '‚ú® AI Enhance';
            }
        }

        function clearPersona() {
            if (confirm('Are you sure you want to clear the persona?')) {
                document.getElementById('persona-text').value = '';
                savePersona();
            }
        }

        async function loadWhisperLanguage() {
            try {
                const response = await fetch('/api/whisper/language');
                const data = await response.json();
                document.getElementById('whisper-language').value = data.language || 'auto';
            } catch (error) {
                console.error('Error loading whisper language:', error);
            }
        }

        async function saveWhisperLanguage() {
            const language = document.getElementById('whisper-language').value;

            try {
                const response = await fetch('/api/whisper/language', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({language})
                });

                if (response.ok) {
                    const successMsg = document.getElementById('whisper-success');
                    successMsg.style.display = 'block';
                    setTimeout(() => successMsg.style.display = 'none', 3000);
                }
            } catch (error) {
                console.error('Error saving whisper language:', error);
            }
        }

        async function loadConversations() {
            try {
                const response = await fetch('/api/conversations?limit=50');
                const data = await response.json();

                const container = document.getElementById('conversation-history');
                container.innerHTML = '';

                if (data.conversations.length === 0) {
                    container.innerHTML = '<p>No conversation history yet</p>';
                    return;
                }

                data.conversations.reverse().forEach(conv => {
                    const msg = document.createElement('div');
                    msg.className = `message ${conv.role}`;

                    const timestamp = new Date(conv.timestamp).toLocaleString();

                    msg.innerHTML = `
                        <div class="message-header">
                            <span><strong>${conv.user_name}</strong> (${conv.role})</span>
                            <span>${conv.message_type} | ${timestamp}</span>
                        </div>
                        <div class="message-content">${conv.message}</div>
                    `;

                    container.appendChild(msg);
                });

                // Scroll to bottom
                container.scrollTop = container.scrollHeight;
            } catch (error) {
                console.error('Error loading conversations:', error);
            }
        }

        async function resetConversations() {
            if (!confirm('Are you sure you want to delete all conversation history? This cannot be undone.')) {
                return;
            }

            try {
                const response = await fetch('/api/conversations/reset', {method: 'POST'});
                const data = await response.json();

                if (data.success) {
                    alert(`Deleted ${data.deleted} messages`);
                    loadConversations();
                    loadStats();
                }
            } catch (error) {
                console.error('Error resetting conversations:', error);
            }
        }
    </script>
</body>
</html>
